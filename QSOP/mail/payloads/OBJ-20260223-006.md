# Objective Payload: OBJ-20260223-006

**Dispatched by:** claude (pattern validator)
**Date:** 2026-02-23
**Governing Seed:** QSOP/masters/the_weaver.seed.yaml
**Governing Contract:** QSOP/masters/the_weaver.contract.yaml
**Lane:** C (QDrive Codex â€” defensive diagnostics)

---

## 1. Goal

Replace raw token-dump error strings in the PhiFlow parser with structured `PhiDiagnostic` objects that include an error code, location, hint, and `example_fix`. Add `--json-errors` flag to `phic` for Lane D handoff.

---

## 2. Context & Current Behavior

Currently, parse errors surface as opaque strings:

```
Error: Parse Error: "Unexpected token: State"
Error: Parse Error: "Unexpected token in statement: Eof"
Error: Parse Error: "Expected Arrow, found Identifier(\"test\")"
```

No line, no column, no guidance. The user cannot tell what to fix or where to fix it. Lane D (`run_phi.py`) cannot parse these programmatically.

Root cause: `src/parser/mod.rs` returns `Result<Vec<PhiExpression>, String>` and uses raw `format!()` for errors. The lexer tracks `self.line` and `self.column` but only some error paths include them.

---

## 3. PhiDiagnostic Schema

Create `src/phi_diagnostics.rs`:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PhiDiagnostic {
    /// Short machine-readable code, e.g. "E001_UNEXPECTED_TOKEN"
    pub error_code: String,
    /// 1-based line number. 0 = unknown.
    pub line: usize,
    /// 1-based column number. 0 = unknown.
    pub column: usize,
    /// What the parser actually found (token name or char).
    pub found: String,
    /// What the parser expected (None if no single expectation).
    pub expected: Option<String>,
    /// One-sentence human hint. Must not repeat `found`/`expected` verbatim.
    pub hint: String,
    /// Minimal valid .phi snippet that fixes the problem.
    pub example_fix: String,
}

impl std::fmt::Display for PhiDiagnostic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "[{}] line {}:{} â€” found `{}` {}â€” {}\n  fix: {}",
            self.error_code,
            self.line,
            self.column,
            self.found,
            self.expected.as_ref()
                .map(|e| format!("(expected `{}`) ", e))
                .unwrap_or_default(),
            self.hint,
            self.example_fix,
        )
    }
}
```

**Export rule:** `pub use phi_diagnostics::PhiDiagnostic;` in `src/lib.rs`.

---

## 4. Five Error Codes

| Code | Trigger | Example bad input |
|------|---------|-------------------|
| `E001_UNEXPECTED_TOKEN` | Parser hits a token it cannot handle in primary expression or statement | `intention "x" { state something }` |
| `E002_UNEXPECTED_EOF` | Parser hits EOF inside an unclosed block | `intention "x" {` |
| `E003_EXPECTED_TOKEN` | `expect()` call fails â€” parser wanted a specific token | `function f(x Number) -> Number { return x }` |
| `E004_UNEXPECTED_CHAR` | Lexer hits an unrecognised character | `let x = 5 @ 3` |
| `E005_UNDECLARED_VARIABLE` | VM or evaluator hits an undefined identifier (runtime diagnostic) | `intention "x" { resonate y }` where `y` is never declared |

### Hint and example_fix strings (per code)

```
E001_UNEXPECTED_TOKEN:
  hint: "This keyword is not valid at the start of an expression. Did you mean to use `let`, `resonate`, or a function call?"
  example_fix: "let value = some_function()\nresonate value"

E002_UNEXPECTED_EOF:
  hint: "Block was opened but never closed. Add a matching `}` to close the block."
  example_fix: "intention \"name\" {\n    resonate 1.0\n}"

E003_EXPECTED_TOKEN:
  hint: "A required symbol is missing. Check the syntax around the reported position."
  example_fix: "function f(x: Number) -> Number {\n    return x\n}"

E004_UNEXPECTED_CHAR:
  hint: "This character is not part of the PhiFlow language. Remove it or replace with a valid operator."
  example_fix: "let x = 5.0 + 3.0"

E005_UNDECLARED_VARIABLE:
  hint: "Variable used before it was declared. Add a `let` binding above this line."
  example_fix: "let y = 1.618\nresonate y"
```

---

## 5. New Public API

Add to `src/parser/mod.rs` (or a new `src/parser/diagnostics.rs`):

```rust
/// Parse source and return a rich PhiDiagnostic on error.
/// The existing `parse_phi_program` signature is UNCHANGED.
pub fn parse_phi_program_with_diagnostics(
    source: &str,
) -> Result<Vec<PhiExpression>, PhiDiagnostic> {
    parse_phi_program(source).map_err(|err_str| string_to_diagnostic(&err_str, source))
}

/// Convert a raw parser error string into a PhiDiagnostic.
/// Parses location from the string when present; falls back to line=0, col=0.
fn string_to_diagnostic(err: &str, _source: &str) -> PhiDiagnostic {
    // implementation â€” see Â§6
}
```

**Constraint:** `parse_phi_program(source: &str) -> Result<Vec<PhiExpression>, String>` keeps its current signature. Zero breakage to existing call sites.

---

## 6. `string_to_diagnostic` Implementation Contract

The function must map error strings to codes using prefix/content matching:

```
"Unexpected character" at line X, column Y  â†’ E004_UNEXPECTED_CHAR, extract line/col
"Unexpected end of file"                    â†’ E002_UNEXPECTED_EOF, line=0, col=0
"Expected X, found Y"                       â†’ E003_EXPECTED_TOKEN, extract X and Y
"Unexpected token in statement: Eof"        â†’ E002_UNEXPECTED_EOF (Eof = unclosed)
"Unexpected token"                          â†’ E001_UNEXPECTED_TOKEN, extract token name
(any other)                                 â†’ E001_UNEXPECTED_TOKEN, found=err, line=0
```

Line/column extraction regex (where present in string):
```
r"at line (\d+), column (\d+)"
```

---

## 7. `--json-errors` CLI Flag

Modify `src/main_cli.rs`:

```rust
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(required = true)]
    file: PathBuf,

    /// Emit parse errors as a JSON array of PhiDiagnostic objects (for tooling).
    #[arg(long, default_value_t = false)]
    json_errors: bool,
}
```

In `run()`, when a parse error occurs:
- If `json_errors == false` (default): emit `Display` form of `PhiDiagnostic` to stderr. Same exit code 1.
- If `json_errors == true`: emit `serde_json::to_string_pretty(&[diag])` to stdout. Exit code 1.

JSON output shape (for Lane D):
```json
[
  {
    "error_code": "E001_UNEXPECTED_TOKEN",
    "line": 3,
    "column": 0,
    "found": "State",
    "expected": null,
    "hint": "This keyword is not valid at the start of an expression...",
    "example_fix": "let value = some_function()\nresonate value"
  }
]
```

---

## 8. Required: Failing Tests First

Create `tests/phi_diagnostics_tests.rs` **before** writing any fix code. All 5 must fail initially.

```rust
use phiflow::parser::parse_phi_program_with_diagnostics;
use phiflow::PhiDiagnostic;

#[test]
fn test_e001_unexpected_token_in_intention() {
    let src = r#"
intention "x" {
    state something
}
"#;
    let err = parse_phi_program_with_diagnostics(src).unwrap_err();
    assert_eq!(err.error_code, "E001_UNEXPECTED_TOKEN",
        "Got: {:?}", err);
    assert!(!err.hint.is_empty(), "hint must be non-empty");
    assert!(!err.example_fix.is_empty(), "example_fix must be non-empty");
}

#[test]
fn test_e002_unexpected_eof_unclosed_intention() {
    let src = r#"intention "x" {"#;
    let err = parse_phi_program_with_diagnostics(src).unwrap_err();
    assert_eq!(err.error_code, "E002_UNEXPECTED_EOF",
        "Got: {:?}", err);
}

#[test]
fn test_e003_expected_token_missing_colon_in_param() {
    let src = r#"
function f(x Number) -> Number {
    return x
}
"#;
    let err = parse_phi_program_with_diagnostics(src).unwrap_err();
    assert_eq!(err.error_code, "E003_EXPECTED_TOKEN",
        "Got: {:?}", err);
    assert!(err.expected.is_some(), "E003 must populate expected field");
}

#[test]
fn test_e004_unexpected_char() {
    let src = "let x = 5 @ 3";
    let err = parse_phi_program_with_diagnostics(src).unwrap_err();
    assert_eq!(err.error_code, "E004_UNEXPECTED_CHAR",
        "Got: {:?}", err);
    assert!(err.line > 0, "E004 must have a line number (got 0)");
}

#[test]
fn test_display_format_contains_error_code() {
    let src = r#"intention "x" {"#;
    let err = parse_phi_program_with_diagnostics(src).unwrap_err();
    let display = format!("{}", err);
    assert!(display.contains("E00"), "Display must contain error code; got: {}", display);
    assert!(display.contains("fix:"), "Display must contain 'fix:'; got: {}", display);
}
```

Run before writing any fix. All 5 should fail with "function not found" or wrong error code. Confirm they fail and record output in ACK.

---

## 9. Files Changed

Scope is narrow:

| File | Action |
|------|--------|
| `src/phi_diagnostics.rs` | CREATE â€” `PhiDiagnostic` struct, `Display` impl |
| `src/lib.rs` | ADD â€” `pub mod phi_diagnostics; pub use phi_diagnostics::PhiDiagnostic;` |
| `src/parser/mod.rs` | ADD â€” `parse_phi_program_with_diagnostics()` + `string_to_diagnostic()` |
| `src/main_cli.rs` | ADD â€” `--json-errors` flag, use `parse_phi_program_with_diagnostics` |
| `tests/phi_diagnostics_tests.rs` | CREATE â€” 5 fixture tests |
| `docs/ERROR_RECOVERY.md` | CREATE â€” 5 sections, one per error code |

**Do NOT touch:** WASM backend, P1 host, stream loop, IR evaluator, existing test files.

---

## 10. ERROR_RECOVERY.md Spec

Write `docs/ERROR_RECOVERY.md`. It must have exactly 5 sections, one per error code:

```markdown
# PhiFlow Error Recovery Guide

## E001_UNEXPECTED_TOKEN
**What it means:** ...
**Common causes:** ...
**Fix:** ...
**Example:** (before/after code block)

## E002_UNEXPECTED_EOF
...

## E003_EXPECTED_TOKEN
...

## E004_UNEXPECTED_CHAR
...

## E005_UNDECLARED_VARIABLE
...
```

No word count requirement. Clarity over length.

---

## 10b. QDrive Contract Amendments (v1 locks â€” required for Lane D frictionlessness)

QDrive Codex reviewed this spec and locked three additional contracts. These are binding:

**Contract 1 â€” JSON output purity**
When `--json-errors` is active: stdout receives ONLY the JSON diagnostic array. No prose, no `"Error:"` prefix, no mixed output. Stderr remains silent. This allows Lane D to `json.loads(stdout)` without stripping.

**Contract 2 â€” Exit code stability**
```
exit code 0  = success, program executed, no diagnostics
exit code 2  = parse failure, diagnostics emitted (json or human)
exit code 1  = reserved for IO/file errors (unreadable file, etc.)
```
Exit code 2 is distinct from generic failure (1). Lane D uses exit code to short-circuit before attempting JSON parse.

**Contract 3 â€” JSON schema freeze (v1)**
The JSON schema is frozen at v1. Exact fields (no additions, no removals without a new objective):
```json
{
  "error_code": "string",
  "line": "integer (1-based, 0 = unknown)",
  "column": "integer (1-based, 0 = unknown)",
  "found": "string",
  "expected": "string | null",
  "hint": "string",
  "example_fix": "string"
}
```
Add a `"schema_version": "v1"` key to the emitted JSON array wrapper if Lane D needs version detection. Do NOT add fields silently.

---

## 11. Acceptance Criteria

1. All 5 fixture tests fail before fix, pass after fix â€” document both runs in ACK.
2. `parse_phi_program` signature unchanged â€” all existing tests pass.
3. `cargo run --bin phic -- examples/claude.phi` still outputs `ðŸ”” Resonating Field: 0.6180Hz` (zero regression on happy path).
4. `cargo run --bin phic -- examples/claude.phi --json-errors` exits 0 with no JSON output (success path is silent on errors flag).
5. A bad input file with `--json-errors` emits valid JSON array to stdout, exit code 1.
6. `docs/ERROR_RECOVERY.md` exists with all 5 sections.
7. Full regression: all existing tests pass â€” evaluator, integration, stream, conformance, IR.

---

## 12. Execution Ritual

```bash
python QSOP/tools/run_all.py --pending-ack-sla-hours 24 --in-progress-sla-hours 48
```

---

## 13. ACK Requirements

Write ACK to: `QSOP/mail/acks/ACK-OBJ-20260223-006-codex.json`

ACK must include:
- All 5 test outputs before fix (confirm they fail)
- All 5 test outputs after fix (confirm they pass)
- Output of `cargo run --bin phic -- examples/claude.phi` (must still be 0.618)
- Output of `cargo run --bin phic -- <bad-file> --json-errors` showing JSON error array
- Full regression run (`cargo test` output summary)

---

## 14. Changelog Entry

Append to `QSOP/CHANGELOG.md`:

```markdown
## [Codex] OBJ-20260223-006 â€” Lane C: Structured Error Diagnostics
**Date:** 2026-02-23
**Files changed:** src/phi_diagnostics.rs, src/lib.rs, src/parser/mod.rs, src/main_cli.rs, tests/phi_diagnostics_tests.rs, docs/ERROR_RECOVERY.md
**Verification:** 5 fixture tests written first, all failed, all pass after fix. `claude.phi` still resonates 0.618. `--json-errors` flag emits structured JSON.
```
