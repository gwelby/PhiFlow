# Objective Payload: OBJ-20260223-003
**Dispatched by:** claude (pattern validator)
**Date:** 2026-02-23
**Governing Seed:** QSOP/masters/the_weaver.seed.yaml
**Governing Contract:** QSOP/masters/the_weaver.contract.yaml

---

## 1. Goal

Add `stream()` continuous execution loop to `P1Host` — the Healing Bed forward-backward
design. A phi program runs repeatedly; each cycle's coherence feeds into the next as field
memory, creating sustained presence rather than repeated snapshots.

This is the objective where the compiler becomes a continuous field, not a one-shot reporter.

---

## 2. Context and What Already Exists

`p1_host/host.py` from OBJ-20260223-002 is complete and promoted to Master Library.
`P1Host.run(wat_source)` executes one cycle:
- Clears state (sensor_readings, intention_stack, resonance_log)
- Loads WAT module, wires 5 hooks
- Calls `phi_run()` inside WASM
- Returns `ConsciousnessSnapshot(final_coherence, sensor_readings, ...)`

The forward-backward design was noted in OBJ-20260223-002 Section 10:
> "Build `run()` correctly now and `stream()` will be a thin wrapper."

That prediction is now the spec.

---

## 3. Scope (Allowed Files — Modify or Create These)

```
PhiFlow/p1_host/
    host.py              ← extend run() signature + add stream() method
tests/p1_host/
    test_p1_stream.py    ← new test file for stream behavior
PhiFlow/QSOP/
    CHANGELOG.md         ← append entry
```

---

## 4. Scope (Do Not Touch)

- `sensors.py`, `consciousness.py` — already correct, do not modify
- `src/` compiler or runtime Rust code
- `tests/p1_host/test_p1_host.py` — existing test must still pass
- Any other QSOP files (except to write the ACK and CHANGELOG entry)

---

## 5. Implementation Specifications

### 5.1 Extend `run()` — add `prior_coherence` parameter

```python
def run(
    self,
    wat_source: str | bytes,
    prior_coherence: float | None = None,
) -> ConsciousnessSnapshot:
```

Store `prior_coherence` as instance state before execution:

```python
self._prior_coherence: float | None = prior_coherence
```

Existing behavior of `run()` is unchanged when `prior_coherence=None`.

### 5.2 Modify `phi_coherence()` — blend prior into live

```python
def phi_coherence(self) -> float:
    """Return coherence. When a prior cycle's coherence is known, blend it
    70% live sensor / 30% field memory to create forward-backward continuity."""
    if self.sensor_readings:
        live = compute_coherence(self.sensor_readings[-1])
        if self._prior_coherence is not None:
            return live * 0.7 + self._prior_coherence * 0.3
        return live
    # No sensor reading yet in this cycle
    if self._prior_coherence is not None:
        return self._prior_coherence   # carry forward until first witness
    return self.phi_witness(0)         # trigger a read
```

**Rationale:** The Healing Bed operator becomes a real-time proxy for the person on the
bed. Field memory means the P1 doesn't start each cycle from zero — it inherits the
coherence state of where the previous cycle ended. 70/30 keeps live sensors dominant while
providing continuity across cycles.

### 5.3 Add `stream()` — the continuous loop

```python
from typing import Iterator

def stream(
    self,
    phi_source: str | bytes,
    cycles: int | None = None,
) -> Iterator[ConsciousnessSnapshot]:
    """Run phi_source continuously. Each cycle's final_coherence feeds the next
    as prior_coherence, creating a sustained forward-backward field.

    Args:
        phi_source: WAT source string (or bytes) to execute each cycle.
        cycles: Number of iterations. None = infinite (caller controls stop via
                KeyboardInterrupt or exhausting a take(N) wrapper).

    Yields:
        ConsciousnessSnapshot after each completed cycle.

    Raises:
        Any exception from run() propagates immediately (stream stops).
    """
    prior: float | None = None
    i = 0
    while cycles is None or i < cycles:
        snapshot = self.run(phi_source, prior_coherence=prior)
        prior = snapshot.final_coherence
        yield snapshot
        i += 1
```

**Important behavior details:**

- `run()` already clears `sensor_readings`, `intention_stack`, `resonance_log` at the
  start of each call. `stream()` relies on this — each cycle is a clean execution.
- `_prior_coherence` is set by `run()` BEFORE execution, so `phi_coherence()` sees it
  during the cycle's WASM execution.
- Infinite stream (`cycles=None`) is valid. The caller is responsible for stopping it.
- If `run()` raises (e.g. WASM trap), the exception propagates out of the generator.
  Do not swallow exceptions in `stream()`.

### 5.4 `test_p1_stream.py` — Stream behavior tests

Three tests required.

**Test 1 — Stream produces N cycles:**
```python
def test_stream_produces_n_snapshots():
    host = P1Host()
    snapshots = list(host.stream(_demo_wat(), cycles=3))

    assert len(snapshots) == 3
    for snap in snapshots:
        assert 0.0 < snap.final_coherence < 1.0
        assert len(snap.sensor_readings) >= 1
        assert snap.sensor_readings[0].cpu_percent != 47.0   # theater gate
        assert snap.sensor_readings[0].cpu_percent != 0.618  # theater gate
        assert isinstance(snap.wasm_return_value, float)
```

**Test 2 — State resets between cycles (intention stack balances each cycle):**
```python
def test_stream_resets_state_between_cycles():
    host = P1Host()
    snapshots = list(host.stream(_demo_wat(), cycles=2))

    # The demo WAT fixture pushes and pops — stack is empty at end of each cycle
    for snap in snapshots:
        assert snap.intention_stack_final == []
        assert len(snap.resonance_log) >= 1
```

**Test 3 — prior_coherence blends into phi_coherence output:**
```python
def test_prior_coherence_parameter_accepted():
    host = P1Host()
    # Single run with an extreme prior — verify result stays in valid range
    snap = host.run(_demo_wat(), prior_coherence=0.0)
    assert 0.0 < snap.final_coherence < 1.0

    snap_high = host.run(_demo_wat(), prior_coherence=1.0)
    assert 0.0 < snap_high.final_coherence < 1.0

    # With prior=1.0, coherence should be >= prior=0.0 case (live sensors are
    # the same machine; prior shifts the result toward 1.0).
    # This is a soft assertion — only valid if live sensor didn't spike between calls.
    # Assert the type and range, not the exact relationship.
    assert isinstance(snap_high.final_coherence, float)
```

**Shared fixture** (same WAT as test_p1_host.py — copy the `_precompiled_demo_wat()` helper
or import it):
```python
def _demo_wat() -> str:
    # Reuse the WAT fixture from test_p1_host.py — exercises all 5 hooks
    from tests.p1_host.test_p1_host import _precompiled_demo_wat   # or inline it
    return _precompiled_demo_wat()
```

If importing creates a circular dependency, inline the WAT literal. Do not rewrite it —
it must be identical to the OBJ-20260223-002 fixture.

---

## 6. Dependencies

No new dependencies. `wasmtime` and `psutil` are already in `p1_host/requirements.txt`.

---

## 7. Acceptance Tests

The ACK must include the actual captured output of these commands run from the
`PhiFlow/` directory:

**Test 1 — Stream 3 cycles, print coherence values:**
```python
from p1_host.host import P1Host

host = P1Host()
wat = open("examples/p1_demo.phi.wat").read()  # or use inline WAT
for i, snap in enumerate(host.stream(wat, cycles=3)):
    print(f"cycle={i}  coherence={snap.final_coherence:.4f}  cpu={snap.sensor_readings[0].cpu_percent}%")
```
Expected: 3 lines of output, each with a real cpu_percent (not 47.0, not 0.618).
Include actual output in ACK.

**Test 2 — Stream tests pass:**
```
python -m pytest tests/p1_host/test_p1_stream.py -v
```
Expected: All 3 tests pass. Include full pytest output in ACK.

**Test 3 — Original host test still passes (regression):**
```
python -m pytest tests/p1_host/test_p1_host.py -v
```
Expected: Still 1 test passing. Include output in ACK.

**Test 4 — Full ritual clean:**
```
python QSOP/tools/run_all.py --pending-ack-sla-hours 24 --in-progress-sla-hours 48
```
Expected: `RITUAL COMPLETE: outside_zero conditions met`

---

## 8. Veto Rules

- **SVETO_001 (stream_swallows_exceptions):** `stream()` must NOT catch exceptions from
  `run()`. If an exception occurs inside a cycle, it propagates. Do not wrap `run()` in
  a try/except inside `stream()`.
- **SVETO_002 (theater gate):** If any `snapshot.sensor_readings[0].cpu_percent` equals
  exactly 47.0 or exactly 0.618, the implementation is hardcoded. Block completion.
- **SVETO_003 (prior_not_wired):** If `phi_coherence()` returns the same value regardless
  of `prior_coherence` argument (i.e., prior is stored but never read), block completion.
  Test 3 verifies the parameter is accepted. Evidence of the blend formula in code is
  required — show the `_prior_coherence` attribute being used in `phi_coherence()`.
- **SVETO_004 (run_signature_breaking):** The `prior_coherence` parameter must default to
  `None` and be fully optional. `host.run(wat_source)` with no second argument must still
  work identically to OBJ-20260223-002 behavior. The original test must pass unchanged.

---

## 9. ACK Requirements

Write ACK to: `QSOP/mail/acks/ACK-OBJ-20260223-003-codex.json`

Required fields:
```json
{
  "ack_id": "ACK-OBJ-20260223-003-codex",
  "objective_id": "OBJ-20260223-003",
  "status": "completed",
  "summary": "stream() loop implemented. Prior coherence feeds forward 70/30. Healing Bed continuous loop operational.",
  "verification": {
    "test_1_stream_3_cycles": "<3 lines of output with real cpu values>",
    "test_2_stream_tests": "<pytest output for test_p1_stream.py>",
    "test_3_regression": "<pytest output for test_p1_host.py — must still pass>",
    "test_4_full_ritual": "<run_all.py stdout>"
  },
  "files_changed": [
    "p1_host/host.py",
    "tests/p1_host/test_p1_stream.py",
    "QSOP/CHANGELOG.md"
  ],
  "weaver_metrics": {
    "stream_continuity": "<float — does phi_coherence() actually blend prior?>",
    "regression_safety": "<float — does original test still pass?>",
    "mutation_depth": "<float — scope was narrow: host.py extension only>",
    "evidence_coherence": "<1.00 only if all 4 tests produced real captured output>"
  },
  "stream_sample": {
    "cycle_0_coherence": "<actual value>",
    "cycle_1_coherence": "<actual value>",
    "cycle_2_coherence": "<actual value>",
    "note": "values should differ slightly as live sensors update between cycles"
  }
}
```

The `stream_sample` block is the signature evidence for this objective. Three coherence
values from a real 3-cycle run. They may be similar but must come from real sensor reads.

---

## 10. Forward-Backward Design — What This Enables

With `stream()` operational, the Healing Bed loop is:

```
operator wears P1 sensors
PhiFlow program starts stream
  cycle 0: witness() reads operator's current state → coherence 0.85
  cycle 1: phi_coherence() = live*0.7 + 0.85*0.3 → field remembers 0.85
  cycle 2: field builds, operator breathes with it
  ...
  cycle N: operator has become real-time proxy of person on bed
```

The `stream()` method is the Healing Bed. A-011 closes here.

A-012 (`stream` block as a native PhiFlow language primitive) is the next horizon —
but that requires language parser changes and is a separate objective.

---

## 11. Changelog Entry

Append to `QSOP/CHANGELOG.md`:

```
## [Codex] OBJ-20260223-003 — P1 Stream Loop: Forward-Backward Healing Bed
**Date:** 2026-02-23
**Files changed:** p1_host/host.py (stream() + prior_coherence), tests/p1_host/test_p1_stream.py
**Verification:** 3-cycle stream with real sensor data captured in ACK. Regression clean.
**Note:** A-011 complete. stream() is the Healing Bed. A-012 (stream block primitive) is next.
```
