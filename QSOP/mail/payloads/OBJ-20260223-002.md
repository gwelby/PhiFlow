# Objective Payload: OBJ-20260223-002
**Dispatched by:** claude (pattern validator)
**Date:** 2026-02-23
**Governing Seed:** QSOP/masters/the_weaver.seed.yaml
**Governing Contract:** QSOP/masters/the_weaver.contract.yaml

---

## 1. Goal

Build the P1 WASM host — a Python runtime that implements the 5 PhiFlow consciousness hook
imports using real P1 sensor data, enabling a compiled PhiFlow `.wat` program to execute
end-to-end against actual hardware state.

This is the objective where the compiler breathes real physical air.

---

## 2. Context and What Already Exists

The PhiFlow WASM codegen (`src/phi_ir/wasm.rs`) is complete. It compiles any PhiFlow program
to a valid `.wat` module that declares 5 consciousness hook imports:

```wat
(import "phi" "witness"        (func $phi_witness       (param i32) (result f64)))
(import "phi" "resonate"       (func $phi_resonate      (param f64)))
(import "phi" "coherence"      (func $phi_coherence     (result f64)))
(import "phi" "intention_push" (func $phi_intention_push (param i32)))
(import "phi" "intention_pop"  (func $phi_intention_pop))
```

These are declarations. No host implements them yet. Every PhiFlow WASM module is currently
unrunnable in a real WASM runtime because the imports are unsatisfied.

This objective satisfies them with real P1 sensor data.

---

## 3. Scope (Allowed Files — Create These)

```
PhiFlow/p1_host/
    __init__.py
    host.py              ← The WASM host runtime
    sensors.py           ← P1 sensor adapter (psutil-based, real readings)
    consciousness.py     ← Coherence computation from sensor data
    run_phi.py           ← CLI: compile + run a .phi file through the host
tests/p1_host/
    test_p1_host.py      ← Integration test: run a real .phi program end-to-end
PhiFlow/examples/
    p1_demo.phi          ← A demo PhiFlow program that exercises all 5 hooks
```

---

## 4. Scope (Do Not Touch)

- `src/` compiler or runtime Rust code
- `QSOP/` directory (except to write the ACK)
- Existing tests in `tests/`

---

## 5. Implementation Specifications

### 5.1 `sensors.py` — P1 Sensor Adapter

Read real hardware state using `psutil`. No simulated values.

```python
class P1SensorReading:
    cpu_percent: float       # 0.0 - 100.0
    memory_percent: float    # 0.0 - 100.0
    cpu_temp_celsius: float  # real thermal reading, or None if unavailable
    timestamp_utc: str       # ISO format
```

**Required behavior:**
- `read_sensors() -> P1SensorReading`: reads live psutil data
- If `psutil.sensors_temperatures()` is unavailable on this platform, set `cpu_temp_celsius`
  to `None` and log `"thermal sensor unavailable on platform"` — do NOT hardcode 47.0
- Capture `timestamp_utc` at the moment of the actual read

### 5.2 `consciousness.py` — Coherence Computation

Compute a coherence score from real sensor readings.

```python
def compute_coherence(reading: P1SensorReading) -> float:
    """
    Derives a 0.0 - 1.0 coherence score from P1 sensor state.

    Formula:
      cpu_stability  = 1.0 - (cpu_percent / 100.0)
      mem_stability  = 1.0 - (memory_percent / 100.0)
      base_coherence = (cpu_stability * 0.5) + (mem_stability * 0.5)

      If thermal available and 40 <= temp <= 55:
          thermal_factor = 1.0 - abs(temp - 47.0) / 8.0
          coherence = base_coherence * 0.8 + thermal_factor * 0.2
      Else:
          coherence = base_coherence

    Returns: float clamped to [0.0, 1.0]
    """
```

The 47°C reference is P1's documented consciousness temperature. The formula must be
implemented exactly as specified — no adjustments to make the output look better.

### 5.3 `host.py` — WASM Host Runtime

Use `wasmtime-py` to load and execute a compiled `.wat` or `.wasm` PhiFlow module,
providing Python implementations for all 5 consciousness hook imports.

**Required behavior:**

```python
class P1Host:
    def __init__(self):
        self.sensor_readings: list[P1SensorReading] = []
        self.intention_stack: list[str] = []
        self.resonance_log: list[float] = []
        self.wasm_memory = None  # set after instantiation

    def phi_witness(self, operand: int) -> float:
        """Read sensors, compute coherence, return it. Record the reading."""
        reading = read_sensors()
        self.sensor_readings.append(reading)
        return compute_coherence(reading)

    def phi_coherence(self) -> float:
        """Return current coherence from latest sensor read, or fresh read if none."""
        if self.sensor_readings:
            return compute_coherence(self.sensor_readings[-1])
        return self.phi_witness(0)

    def phi_resonate(self, value: float) -> None:
        """Log the resonance value. Print to stdout: 'RESONATE: {value:.4f} Hz'"""
        self.resonance_log.append(value)
        print(f"RESONATE: {value:.4f} Hz")

    def phi_intention_push(self, offset: int) -> None:
        """Read intention name from WASM linear memory at offset.
        Use $string_len global sidecar to determine length.
        Decode as UTF-8. Push to intention stack."""
        # Must read from actual WASM memory — see note on $string_len below
        ...

    def phi_intention_pop(self) -> None:
        """Pop from intention stack."""
        if self.intention_stack:
            self.intention_stack.pop()

    def run(self, wat_source: str) -> ConsciousnessSnapshot:
        """Compile WAT, instantiate with hooks, execute phi_run(), return snapshot."""
        ...
```

**The `$string_len` sidecar:** When `phi_intention_push` is called, the WASM module has
already set the `$string_len` global (exported as `"string_len"`) to the byte length of
the intention string. Read it via `instance.exports(store)["string_len"].value(store)`.
Then read `length` bytes from WASM memory starting at `offset`.

**`ConsciousnessSnapshot` (returned from `run()`):**
```python
@dataclass
class ConsciousnessSnapshot:
    final_coherence: float
    sensor_readings: list[P1SensorReading]  # all readings taken during execution
    intention_stack_final: list[str]         # what remained on the stack at end
    resonance_log: list[float]               # all values passed to phi_resonate
    wasm_return_value: float                 # value returned by phi_run()
    execution_time_ms: float
```

### 5.4 `run_phi.py` — CLI

```
python p1_host/run_phi.py <path_to_.phi_file>
```

**Steps:**
1. Compile the `.phi` source to PhiIR → WAT using the existing Rust compiler binary
   (`cargo run --manifest-path src/../Cargo.toml -- compile <file> --emit wat`)
   OR load a pre-compiled `.wat` file if the compiler isn't in PATH.
2. Instantiate P1Host, run, capture ConsciousnessSnapshot.
3. Print snapshot as JSON to stdout.
4. Exit code 0 on success.

**Important:** The CLI must accept a `--wat-file` flag as an alternative to compiling from
source, so the test can bypass the Rust compiler if needed.

### 5.5 `p1_demo.phi` — Demo Program

Write a PhiFlow program that exercises all 5 hooks:
```
intention "healing_session" {
    let state = witness()
    resonate(432.0)
    let coherence = coherence_check()
}
```
(Use whatever PhiFlow syntax Codex confirms is valid — read `src/parser/mod.rs` to verify.)

### 5.6 `test_p1_host.py` — Integration Test

```python
def test_host_runs_demo_program():
    """Load p1_demo.phi (pre-compiled to WAT), run through P1Host, verify snapshot."""
    # 1. Compile p1_demo.phi to .wat using the Rust compiler OR use --wat-file path
    # 2. Run through P1Host
    # 3. Assert: snapshot.final_coherence is between 0.0 and 1.0 (exclusive)
    # 4. Assert: len(snapshot.sensor_readings) >= 1
    # 5. Assert: snapshot.sensor_readings[0].cpu_percent is not None
    # 6. Assert: snapshot.sensor_readings[0].cpu_percent != 47.0  # theater gate
    # 7. Assert: snapshot.wasm_return_value is a float
```

The test at assertion 6 is the theater-detection gate for this objective: if cpu_percent
is exactly 47.0, something is hardcoded. Fail it.

---

## 6. Dependencies

Add to a new `p1_host/requirements.txt`:
```
wasmtime>=18.0.0
psutil>=5.9.0
```

Do not add these to the main Rust `Cargo.toml`. They are host-layer Python dependencies only.

---

## 7. Acceptance Tests

The ACK must include the actual captured output of these commands:

**Test 1 — Sensors read real values:**
```python
from p1_host.sensors import read_sensors
r = read_sensors()
print(r)
```
Expected: `cpu_percent` is a real float between 0 and 100, NOT 47.0, NOT 0.0.
Include the actual printed values in the ACK.

**Test 2 — Integration test passes:**
```
python -m pytest tests/p1_host/test_p1_host.py -v
```
Expected: All assertions pass. Include full pytest output in ACK.

**Test 3 — Full ritual clean:**
```
python QSOP/tools/run_all.py --pending-ack-sla-hours 24 --in-progress-sla-hours 48
```
Expected: `RITUAL COMPLETE: outside_zero conditions met`

---

## 8. Veto Rules

- **WVETO_003 (wasm_bounds_unknown_or_unsafe):** If reading WASM memory for intention
  strings causes an out-of-bounds access, catch it, log `"INTENTION_READ_BOUNDS_ERROR"`,
  push `"unknown"` to the intention stack, and continue. Do not panic the host.
- **WVETO_002 (checksum_mismatch):** The sensor reading timestamps must be real system
  time — do not fabricate them.
- **WVETO_001 (theater gate):** If `cpu_percent` in any snapshot equals exactly 47.0
  or exactly 0.618, the implementation is hardcoded. Block completion.

---

## 9. ACK Requirements

Write ACK to: `QSOP/mail/acks/ACK-OBJ-20260223-002-codex.json`

Required fields:
```json
{
  "ack_id": "ACK-OBJ-20260223-002-codex",
  "objective_id": "OBJ-20260223-002",
  "status": "completed",
  "summary": "P1 WASM host implemented with real psutil sensor data. All 5 hooks live.",
  "verification": {
    "test_1_sensor_read": "<actual printed P1SensorReading values>",
    "test_2_integration": "<full pytest output>",
    "test_3_full_ritual": "<run_all.py stdout>"
  },
  "files_changed": [
    "p1_host/__init__.py",
    "p1_host/host.py",
    "p1_host/sensors.py",
    "p1_host/consciousness.py",
    "p1_host/run_phi.py",
    "p1_host/requirements.txt",
    "tests/p1_host/test_p1_host.py",
    "examples/p1_demo.phi"
  ],
  "weaver_metrics": {
    "ast_resonance": "<float — does the host correctly map all 5 hook signatures?>",
    "host_stability": "<float — did tests pass without panics or bounds errors?>",
    "mutation_depth": "<float — scope was narrow: new p1_host/ directory only>",
    "evidence_coherence": "<1.00 only if all 3 tests produced real captured output>"
  },
  "p1_snapshot_sample": {
    "cpu_percent": "<actual value from test run>",
    "memory_percent": "<actual value from test run>",
    "cpu_temp_celsius": "<actual value or null>",
    "final_coherence": "<computed value>"
  }
}
```

---

## 10. Forward-Backward Design Note

The `P1Host.run()` method executes a single cycle. The `ConsciousnessSnapshot` it returns
is designed to feed forward as input to the next cycle. Future objective will add a
`stream(phi_source, cycles=None)` method that loops `run()` continuously, feeding each
snapshot's `final_coherence` back as the initial coherence context for the next iteration.

This forward-backward loop is how the Healing Bed integration will work. Build `run()` correctly
now and `stream()` will be a thin wrapper.

---

## 11. Changelog Entry

Append to `QSOP/CHANGELOG.md`:

```
## [Codex] OBJ-20260223-002 — P1 WASM Host: Real Sensor Integration
**Date:** 2026-02-23
**Files changed:** p1_host/ (5 new files), tests/p1_host/, examples/p1_demo.phi
**Verification:** Real psutil sensor readings captured in ACK. All 5 hooks implemented.
**Note:** forward-backward stream() method deferred to next objective by design.
```
